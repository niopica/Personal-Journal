Рендеринг jsx
Props
стили
отображение данных

Side-effects - Внутри исполнения компонента
UI=INPUT
работа с JSX
Events
State
Props
Обработка изменений
...

<!-- Работа с эфектами -->

Side Effect - вне цикла evaluate
Работа с LocalStorage
Таймеры
Запросы к API

# Все что не относится к рендеру jsx компонента называется side-effect

useEffect(() => {
console.log('что выполнить')
}, [Если изменились, items])

# useReducer - как useState, но с большим функционалом

const [state, dispatchFn] = useReducer(reduceFn, INITIAL_STATE, initFN)
state - состояние
dispatchFn - функция изменения
reduceFn - функция изменения состояния по action
INITIAL_STATE - начальное состояние
initFn - функция для установки начального состояния

1. Поднятие гантель на вытянутых руках вперед обратным хватом на 1 руку на 2 руку и обеими 3 по 15 минута отдыха верхняя грудная
2. Положение лежа поднятие одной гантели двумя руками от себя 3 по 15 между грудных
3. Недомостик с двумя гантелями поднимаем их слева и справа от себя 3 по 15 раз нижняя часть грудных
4. Положение лежа от себя две гантели по очереди и потом вместе на диване ноги спущены середина грудных
5. На диване лечь и за себя закидывать гирю и подымать обратно

Правила hooks

1. Можно использовать только в:
   Компонентах
   Custom Hooks
2. Вызывать только на верхнем уровне:
   Нельзя во вложенных функциях
   Нельзя в блоках (if, switch ...)
3. Все названия hooks начинаются с use

<!-- Ограничение контекста -->

# Списки

1. Не замена Props для конфигурации компонента
2. Не следует использовать для соседних компонентов
3. Не оптимизировать для частых изменений (Несколько раз в секунду)

<!-- Как работает реакт -->

# Работа React

1. React
   1.1 Компонент обновляется и попадает в ->
   VirtualDOM где происходит сравнение -
   Текущего компонента и Нового компонента
   И всю разницу отправляем в ReactDOM
   где не обновляет полностью компонент,
   а добавляет небольшую новую часть.
   -?props
   -?state
   -?context

2. ReactDOM
   1.1 DOM
